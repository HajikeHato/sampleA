#ifndef JSON_WRAPPER_H
#define JSON_WRAPPER_H

#include <rapidjson/document.h>
#include <rapidjson/prettywriter.h>
#include <rapidjson/filereadstream.h>
#include <rapidjson/filewritestream.h>
#include <cstdio>
#include <string>
#include <vector>
#include <unordered_map>

class JsonWrapper {
public:
    JsonWrapper() : document_(rapidjson::kObjectType) {}

    // JSONファイルからデータを読み込む
    bool loadFromFile(const std::string& filename) {
        FILE* fp = std::fopen(filename.c_str(), "rb");
        if (!fp) {
            return false;
        }

        char buffer[65536]; // 64KB
        rapidjson::FileReadStream is(fp, buffer, sizeof(buffer));
        document_.ParseStream(is);

        std::fclose(fp);
        return !document_.HasParseError();
    }

    // JSONデータをファイルに書き込む
    bool saveToFile(const std::string& filename) {
        FILE* fp = std::fopen(filename.c_str(), "wb");
        if (!fp) {
            return false;
        }

        char buffer[65536]; // 64KB
        rapidjson::FileWriteStream os(fp, buffer, sizeof(buffer));
        rapidjson::PrettyWriter<rapidjson::FileWriteStream> writer(os);
        document_.Accept(writer);

        std::fclose(fp);
        return true;
    }

    // JSONオブジェクトに値を追加
    template<typename T>
    void addValue(const std::string& key, const T& value) {
        rapidjson::Value keyName(key.c_str(), document_.GetAllocator());
        rapidjson::Value jsonValue;
    
        // 値の型に合わせてJSON値を作成
        if constexpr (std::is_same_v<T, int>) {
            jsonValue.SetInt(value);
        } else if constexpr (std::is_same_v<T, double>) {
            jsonValue.SetDouble(value);
        } else if constexpr (std::is_same_v<T, bool>) {
            jsonValue.SetBool(value);
        } else if constexpr (std::is_same_v<T, std::string>) {
            rapidjson::Value jsonStrValue(value.c_str(), document_.GetAllocator());
            jsonValue.SetString(jsonStrValue.GetString(), jsonStrValue.GetStringLength(), document_.GetAllocator());
        } else {
            // その他の型はサポートされていません
            static_assert(false, "Unsupported type for addValue");
        }
    
        document_.AddMember(keyName, jsonValue, document_.GetAllocator());
    }

    // JSONオブジェクトから値を取得
    template<typename T>
    T getValue(const std::string& key, const T& defaultValue = T()) const {
        if (document_.HasMember(key.c_str())) {
            const rapidjson::Value& value = document_[key.c_str()];
            return value.Get<T>();
        }
        return defaultValue;
    }

    // JSONオブジェクトに配列を追加
    template<typename T>
    void addArray(const std::string& key, const std::vector<T>& values) {
        rapidjson::Value keyName(key.c_str(), document_.GetAllocator());
        rapidjson::Value jsonArray(rapidjson::kArrayType);

        for (const auto& value : values) {
            rapidjson::Value jsonValue(value);
            jsonArray.PushBack(jsonValue, document_.GetAllocator());
        }

        document_.AddMember(keyName, jsonArray, document_.GetAllocator());
    }

    // JSONオブジェクトから配列を取得
    template<typename T>
    std::vector<T> getArray(const std::string& key) const {
        std::vector<T> result;

        if (document_.HasMember(key.c_str())) {
            const rapidjson::Value& jsonArray = document_[key.c_str()];
            if (jsonArray.IsArray()) {
                for (rapidjson::SizeType i = 0; i < jsonArray.Size(); ++i) {
                    const rapidjson::Value& value = jsonArray[i];
                    if (value.Is<T>()) {
                        result.push_back(value.Get<T>());
                    }
                }
            }
        }

        return result;
    }

    // JSONオブジェクトにObjectの配列を追加
    void addObjectArray(const std::string& key, const std::vector<std::unordered_map<std::string, std::string>>& objects) {
        rapidjson::Value keyName(key.c_str(), document_.GetAllocator());
        rapidjson::Value jsonArray(rapidjson::kArrayType);

        for (const auto& object : objects) {
            rapidjson::Value jsonObject(rapidjson::kObjectType);
            for (const auto& pair : object) {
                rapidjson::Value jsonKey(pair.first.c_str(), document_.GetAllocator());
                rapidjson::Value jsonValue(pair.second.c_str(), document_.GetAllocator());
                jsonObject.AddMember(jsonKey, jsonValue, document_.GetAllocator());
            }
            jsonArray.PushBack(jsonObject, document_.GetAllocator());
        }

        document_.AddMember(keyName, jsonArray, document_.GetAllocator());
    }

    // JSONオブジェクトからObjectの配列を取得
    std::vector<std::unordered_map<std::string, std::string>> getObjectArray(const std::string& key) const {
        std::vector<std::unordered_map<std::string, std::string>> result;

        if (document_.HasMember(key.c_str())) {
            const rapidjson::Value& jsonArray = document_[key.c_str()];
            if (jsonArray.IsArray()) {
                for (rapidjson::SizeType i = 0; i < jsonArray.Size(); ++i) {
                    const rapidjson::Value& jsonObject = jsonArray[i];
                    if (jsonObject.IsObject()) {
                        std::unordered_map<std::string, std::string> objectMap;
                        for (rapidjson::Value::ConstMemberIterator it = jsonObject.MemberBegin(); it != jsonObject.MemberEnd(); ++it) {
                            if (it->name.IsString() && it->value.IsString()) {
                                objectMap[it->name.GetString()] = it->value.GetString();
                            }
                        }
                        result.push_back(objectMap);
                    }
                }
            }
        }

        return result;
    }

private:
    rapidjson::Document document_;
};

#endif // JSON_WRAPPER_H
