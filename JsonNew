#pragma once

#include <iostream>
#include <fstream>
#include <string>
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/error/en.h>

class JsonWrapper {
public:
    JsonWrapper();

    bool loadFromFile(const std::string& filename);
    bool saveToFile(const std::string& filename);

    template <typename T>
    void setValue(const std::string& key, const T& value);

    template <typename T>
    bool getValue(const std::string& key, T& value) const;

    size_t getArraySize(const std::string& key) const;
    const rapidjson::Value& getArrayItem(const std::string& key, size_t index) const;

    template <typename T>
    void appendToArray(const std::string& key, const T& value);

    template <typename T>
    int findIndexOfValue(const std::string& key, const T& value) const;

    bool hasKey(const std::string& key) const;
    bool removeKey(const std::string& key);
    void clearArray(const std::string& key);
    bool renameKey(const std::string& oldKey, const std::string& newKey);
    void merge(const rapidjson::Value& otherJson);
    bool isEmpty() const;
    void clear();

private:
    rapidjson::Document data_;
};

// インライン関数の定義

inline JsonWrapper::JsonWrapper() {
    data_.SetObject();
}

template <typename T>
void JsonWrapper::setValue(const std::string& key, const T& value) {
    rapidjson::Value jsonValue;
    jsonValue.Set(value);
    data_.AddMember(rapidjson::StringRef(key.c_str()), jsonValue, data_.GetAllocator());
}

template <typename T>
bool JsonWrapper::getValue(const std::string& key, T& value) const {
    if (data_.HasMember(key.c_str())) {
        const rapidjson::Value& jsonValue = data_[key.c_str()];
        if (jsonValue.Is<T>()) {
            value = jsonValue.Get<T>();
            return true;
        }
    }
    return false;
}

inline size_t JsonWrapper::getArraySize(const std::string& key) const {
    if (data_.HasMember(key.c_str()) && data_[key.c_str()].IsArray()) {
        return data_[key.c_str()].Size();
    }
    return 0;
}

inline const rapidjson::Value& JsonWrapper::getArrayItem(const std::string& key, size_t index) const {
    static rapidjson::Value emptyValue;
    if (data_.HasMember(key.c_str()) && data_[key.c_str()].IsArray() && index < data_[key.c_str()].Size()) {
        return data_[key.c_str()][index];
    }
    return emptyValue;
}

template <typename T>
void JsonWrapper::appendToArray(const std::string& key, const T& value) {
    if (!data_.HasMember(key.c_str())) {
        data_.AddMember(rapidjson::StringRef(key.c_str()), rapidjson::Value(rapidjson::kArrayType), data_.GetAllocator());
    }
    data_[key.c_str()].PushBack(value, data_.GetAllocator());
}

template <typename T>
int JsonWrapper::findIndexOfValue(const std::string& key, const T& value) const {
    if (data_.HasMember(key.c_str()) && data_[key.c_str()].IsArray()) {
        const auto& array = data_[key.c_str()].GetArray();
        int index = 0;
        for (const auto& item : array) {
            if (item.Is<T>() && item.Get<T>() == value) {
                return index;
            }
            index++;
        }
    }
    return -1;
}

inline bool JsonWrapper::hasKey(const std::string& key) const {
    return data_.HasMember(key.c_str());
}

inline bool JsonWrapper::removeKey(const std::string& key) {
    if (data_.HasMember(key.c_str())) {
        data_.RemoveMember(key.c_str());
        return true;
    }
    return false;
}

inline void JsonWrapper::clearArray(const std::string& key) {
    if (data_.HasMember(key.c_str()) && data_[key.c_str()].IsArray()) {
        data_[key.c_str()].Clear();
    }
}

inline bool JsonWrapper::renameKey(const std::string& oldKey, const std::string& newKey) {
    if (data_.HasMember(oldKey.c_str()) && !data_.HasMember(newKey.c_str())) {
        auto& allocator = data_.GetAllocator();
        rapidjson::Value newKeyJsonValue;
        newKeyJsonValue.SetString(newKey.c_str(), newKey.size(), allocator);
        rapidjson::Value oldKeyJsonValue;
        oldKeyJsonValue = data_[oldKey.c_str()];
        data_.RemoveMember(oldKey.c_str());
        data_.AddMember(newKeyJsonValue, oldKeyJsonValue, allocator);
        return true;
    }
    return false;
}

inline void JsonWrapper::merge(const rapidjson::Value& otherJson) {
    if (otherJson.IsObject()) {
        for (auto it = otherJson.MemberBegin(); it != otherJson.MemberEnd(); ++it) {
            rapidjson::Value newKey(it->name, data_.GetAllocator());
            data_.AddMember(newKey.Move(), it->value, data_.GetAllocator());
        }
    }
}

inline bool JsonWrapper::isEmpty() const {
    return data_.ObjectEmpty();
}

inline void JsonWrapper::clear() {
    data_.SetObject();
}
