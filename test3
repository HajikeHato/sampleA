クライアント


#include <iostream>
#include <cstring>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/bio.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/sha.h>
#include <fstream>

class TlsClient {
public:
    TlsClient() {
        // ... 以前のコードと同じ ...
    }

    void sendFile(const std::string& serverAddr, int port, const std::string& filename) {
        // ... 以前のコードと同じ ...

        // ファイル名を送信
        SSL_write(ssl, filename.c_str(), filename.length());

        // ファイルを送信
        std::ifstream input_file(filename, std::ios::binary);
        if (!input_file) {
            std::cerr << "Failed to open input file." << std::endl;
            SSL_free(ssl);
            return;
        }

        char buffer[4096];
        while (!input_file.eof()) {
            input_file.read(buffer, sizeof(buffer));
            int bytes_read = input_file.gcount();
            if (bytes_read > 0) {
                SSL_write(ssl, buffer, bytes_read);
            }
        }

        input_file.close();

        // ハッシュ値を受信
        unsigned char received_hash[SHA256_DIGEST_LENGTH];
        int hash_bytes_read = SSL_read(ssl, received_hash, SHA256_DIGEST_LENGTH);
        if (hash_bytes_read != SHA256_DIGEST_LENGTH) {
            std::cerr << "Failed to receive hash." << std::endl;
        }

        // ハッシュチェック
        std::ifstream output_file(filename, std::ios::binary);
        if (!output_file) {
            std::cerr << "Failed to open output file for hash check." << std::endl;
            SSL_free(ssl);
            return;
        }

        SHA256_CTX sha256_ctx;
        SHA256_Init(&sha256_ctx);

        while (!output_file.eof()) {
            output_file.read(buffer, sizeof(buffer));
            int bytes_read = output_file.gcount();
            SHA256_Update(&sha256_ctx, buffer, bytes_read);
        }

        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256_Final(hash, &sha256_ctx);

        output_file.close();

        // ハッシュチェック結果を表示
        if (memcmp(hash, received_hash, SHA256_DIGEST_LENGTH) == 0) {
            std::cout << "Hash check passed. File transfer successful." << std::endl;
        } else {
            std::cout << "Hash check failed. File transfer may be corrupted." << std::endl;
        }

        SSL_shutdown(ssl);
        SSL_free(ssl);
    }
};



サーバ

#include <iostream>
#include <string>
#include <cstring>
#include <fstream>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <openssl/bio.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/sha.h>
#include <thread>

class TlsServer {
public:
    TlsServer() {
        // ... 以前のコードと同じ ...
    }

    void startServer(int port) {
        // ... 以前のコードと同じ ...
    }

private:
    SSL_CTX* ctx;

    void handleConnection(BIO* bio) {
        // ... 以前のコードと同じ ...

        // ファイル名を受信
        char filename_buffer[1024];
        int filename_bytes_read = SSL_read(ssl, filename_buffer, sizeof(filename_buffer));
        if (filename_bytes_read <= 0) {
            std::cerr << "Failed to receive filename." << std::endl;
            SSL_free(ssl);
            return;
        }
        std::string filename(filename_buffer, filename_bytes_read);
        std::cout << "Received filename: " << filename << std::endl;

        // ファイルを受信
        std::ofstream output_file(filename, std::ios::binary);
        if (!output_file) {
            std::cerr << "Failed to open output file." << std::endl;
            SSL_free(ssl);
            return;
        }

        char buffer[4096];
        int bytes_read;

        while ((bytes_read = SSL_read(ssl, buffer, sizeof(buffer))) > 0) {
            output_file.write(buffer, bytes_read);
        }

        if (bytes_read < 0) {
            std::cerr << "File receive error." << std::endl;
        }

        output_file.close();

        // ハッシュチェック
        std::ifstream input_file(filename, std::ios::binary);
        if (!input_file) {
            std::cerr << "Failed to open input file for hash check." << std::endl;
            SSL_free(ssl);
            return;
        }

        SHA256_CTX sha256_ctx;
        SHA256_Init(&sha256_ctx);

        while (!input_file.eof()) {
            input_file.read(buffer, sizeof(buffer));
            int bytes_read = input_file.gcount();
            SHA256_Update(&sha256_ctx, buffer, bytes_read);
        }

        unsigned char hash[SHA256_DIGEST_LENGTH];
        SHA256_Final(hash, &sha256_ctx);

        input_file.close();

        // ハッシュ値をクライアントに送信
        SSL_write(ssl, hash, SHA256_DIGEST_LENGTH);

        SSL_free(ssl);
    }
};
